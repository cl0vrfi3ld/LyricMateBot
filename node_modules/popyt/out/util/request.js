"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const https_1 = require("https");
const url_1 = require("url");
/**
 * @ignore
 */
/* istanbul ignore next */
class Request {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
    }
    api(subUrl, params, token, accessToken) {
        const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) +
            (!accessToken ? (params ? `&key=${token}` : `?key=${token}`) : '');
        return this.get(url, accessToken);
    }
    post(subUrl, params, data, token, accessToken) {
        const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) +
            (!accessToken ? (params ? `&key=${token}` : `?key=${token}`) : '');
        return this._post(url, data, accessToken);
    }
    put(subUrl, params, data, token, accessToken) {
        const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) +
            (!accessToken ? (params ? `&key=${token}` : `?key=${token}`) : '');
        return this._put(url, data, accessToken);
    }
    delete(subUrl, params, token, accessToken) {
        const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) +
            (!accessToken ? (params ? `&key=${token}` : `?key=${token}`) : '');
        return this._delete(url, accessToken);
    }
    imagePost(subUrl, image, imageType, params, token, accessToken) {
        const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) +
            (!accessToken ? (params ? `&key=${token}` : `?key=${token}`) : '');
        return this._post(url, image, accessToken, `image/${imageType}`);
    }
    get(url, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'GET', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req));
    }
    _post(url, data, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'POST', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req, data));
    }
    _put(url, data, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'PUT', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req, data));
    }
    _delete(url, token, contentType = 'application/json') {
        const options = this.parseUrlToOptions(url, 'DELETE', contentType);
        if (token) {
            options.headers['Authorization'] = `Bearer ${token}`;
        }
        return this.req(options, req => this.reqCallback(req));
    }
    parseUrlToOptions(url, type, contentType) {
        const parsed = url_1.parse(url);
        return {
            hostname: parsed.hostname,
            port: parsed.port ? parsed.port : 443,
            path: parsed.path,
            method: type,
            headers: {
                'Content-Type': contentType
            }
        };
    }
    req(options, reqFunction) {
        return new Promise((resolve, reject) => {
            const cb = (res) => {
                let data = '';
                res.setEncoding('utf8');
                res.on('data', chunk => {
                    data += chunk;
                });
                res.on('end', () => {
                    if (res.statusCode === 404) {
                        return reject(new Error('Not found'));
                    }
                    // no content
                    if (res.statusCode === 204) {
                        return resolve();
                    }
                    const parsed = JSON.parse(data);
                    if (parsed.error) {
                        return reject(new Error(parsed.error.message));
                    }
                    return resolve(parsed);
                });
                res.on('error', error => {
                    return reject(error);
                });
            };
            reqFunction(https_1.request(options, cb));
        });
    }
    reqCallback(req, data) {
        req.on('error', error => {
            throw error;
        });
        if (data) {
            req.write(data);
        }
        req.end();
    }
    parseParams(params) {
        if (!params) {
            return '';
        }
        let url = '';
        for (let param in params) {
            url += (!url.includes('?') ? '?' : '&') + param + '=' + params[param];
        }
        return url;
    }
}
exports.Request = Request;

//# sourceMappingURL=request.js.map
